CPU 是执行所有软件的核心组件，因此 CPU 性能分析是性能分析中的一个常见起点。如果发现工作负载受限于 CPU（即“CPU 限制”），可以通过使用专注于 CPU 和处理器的工具进一步分析。虽然存在大量的采样分析器和指标来帮助理解 CPU 的使用情况，但通过 BPF 跟踪，仍然可以在许多方面深入进行 CPU 分析。

本章将介绍如何利用 BPF 进一步优化 CPU 性能分析，帮助解决与 CPU 使用相关的各种问题。以下是本章的学习目标和主要内容：

**学习目标**
1. **理解 CPU 模式、CPU 调度程序的行为和 CPU 缓存**：
	 - CPU 模式包括用户模式、内核模式等，CPU 调度程序负责在不同的线程间分配时间片。
    - CPU 缓存的层次结构（如 L1、L2、L3 缓存）对性能有重大影响，理解其工作原理有助于优化 CPU 使用效率。
2. **理解使用 BPF 进行 CPU 调度、使用情况和硬件分析的领域**：
    - BPF 可以帮助深入分析 CPU 调度策略、线程的 CPU 占用情况以及硬件资源的使用情况，发现潜在的性能瓶颈。
3. **学习成功的 CPU 性能分析策略**：
    - 通过制定清晰的分析步骤，系统地排查 CPU 使用问题。
4. **解决短生命周期进程占用 CPU 资源的问题**：
    - 许多进程可能会在短时间内消耗大量 CPU 资源，BPF 可以帮助识别这些问题进程及其行为。
5. **发现并量化运行队列延迟问题**：
    - 运行队列延迟是指进程等待 CPU 时间片的时间，过长的延迟会导致系统响应变慢。BPF 可帮助跟踪并量化这种延迟。
6. **通过分析堆栈跟踪和函数调用计数来确定 CPU 使用情况**：
    - 堆栈跟踪和函数调用计数可以揭示 CPU 使用的热点区域，帮助识别性能瓶颈。
7. **确定线程为什么会阻塞并离开 CPU**：
    - 使用 BPF 可以分析线程被阻塞的原因，帮助优化线程的调度和资源分配。
8. **通过跟踪系统调用来理解系统 CPU 时间**：
    - 通过系统调用跟踪，可以分析 CPU 在内核中的使用情况，特别是在执行 I/O 或系统操作时。
9. **调查软中断和硬中断的 CPU 消耗**：
    - 中断处理会占用大量 CPU 资源，BPF 可以帮助区分软中断和硬中断的 CPU 使用情况，分析它们对整体性能的影响。
10. **使用 bpftrace 一行命令探索自定义的 CPU 使用方式**：
    - `bpftrace` 提供了强大的一行命令功能，允许用户自定义跟踪 CPU 使用模式，并进行灵活的分析。
## **Traditional Tools for CPU Performance Analysis**
传统工具在 CPU 性能分析中扮演着非常重要的角色，它们能够提供关键的 CPU 使用指标，如每个进程（线程）的 CPU 利用率、每个 CPU 的上下文切换率、平均运行队列长度以及等待运行队列的总时间等。这些工具通常能够帮助分析和解决 CPU 性能瓶颈的问题，并为进一步使用 BPF 工具提供线索。
这些传统工具通常可以分为三类：内核统计、硬件统计和事件跟踪。以下是每种类别的工具及其功能简介。
### **1. Kernel Statistics (内核统计)**
这些工具提供有关内核级 CPU 使用的详细信息，通常专注于进程调度、上下文切换和系统的运行队列。
- **`vmstat`**：提供虚拟内存、进程、CPU 活动的统计信息，特别是上下文切换（voluntary/involuntary）和运行队列的状态。
- **`mpstat`**：显示每个 CPU 的性能统计信息，包括 CPU 的使用情况、上下文切换、负载等。
- **`pidstat`**：显示按 PID（进程 ID）统计的 CPU 使用情况，可以查看每个进程的 CPU 时间。
- **`iostat`**：显示 CPU 利用率和 I/O 设备的统计信息，帮助评估系统的磁盘 I/O 和 CPU 负载。
- **`free`**：显示内存的使用情况，包括交换空间和物理内存的统计。
- **`sar`**：提供全面的 CPU 和系统统计，包括内存使用、进程活动、上下文切换等。
- **`uptime`**：显示系统的平均负载，可以快速查看 CPU 的整体使用情况。
### **2. Hardware Statistics (硬件统计)**
这些工具使用硬件性能计数器来衡量 CPU 的性能，提供更精细的硬件级别指标。
- **`perf`**：这是 Linux 中的一个强大的性能分析工具，支持多种基于硬件的性能计数器，能够监控 CPU 指令周期、缓存命中率、分支预测等硬件级别的事件。
- **`mpstat`（配合硬件性能计数器）**：可以与 `perf` 配合使用，帮助分析每个 CPU 核心的硬件性能。
- **`biosnoop`**：通过监控 I/O 操作，查看磁盘 I/O 的延迟，间接反映 CPU 与硬件交互时的性能瓶颈。
- **`biolatency`**：专门用于监控块设备的 I/O 延迟，帮助诊断由于磁盘 I/O 造成的 CPU 使用问题。
### **3. Event Tracing (事件跟踪)**
事件跟踪工具能够帮助你追踪系统中的具体事件，从而揭示程序行为和性能问题。
- **`trace`**：能够跟踪和记录内核中的各种事件，适用于 CPU 调度、进程执行等方面的分析。
- **`ftrace`**：Linux 内核提供的跟踪框架，允许跟踪内核函数、系统调用等，特别适用于分析 CPU 调度和内核中的工作负载。
- **`dtrace`**：类似于 `ftrace`，这是一个强大的动态追踪框架，能够对内核和用户空间进行跟踪。
- **`strace`**：用于跟踪进程的系统调用，分析进程如何与内核交互，包括文件 I/O、网络通信等，间接揭示 CPU 负载的来源。
### **总结**
在进行 BPF 分析之前，了解这些传统工具的输出结果将为你提供重要的上下文信息，帮助你更有效地利用 BPF 工具进行定制化的性能调优。

## **BPF Tools**
在 CPU 性能分析和故障排除中，BPF 工具提供了强大的功能。本节将介绍用于 CPU 分析的 BPF 工具，这些工具可以帮助你更深入地了解 CPU 使用情况、进程调度、上下文切换等方面的细节。工具的来源包括 **BCC** 和 **bpftrace** 存储库（在第 4 章和第 5 章中已讨论），以及本书中特别创建的一些工具。
### **BPF 工具概览**
图 6-4 展示了用于 CPU 性能分析的 BPF 工具。以下是这些工具的简要总结，以及它们来自的不同存储库或工具集。
### **常见的 BPF 工具列表**

| **工具**           | **来源**       | **功能**                              |
| ---------------- | ------------ | ----------------------------------- |
| **`funccount`**  | BCC          | 对特定函数的调用进行计数，帮助分析函数执行频率和性能瓶颈。       |
| **`stackcount`** | BCC          | 通过分析堆栈跟踪，帮助发现代码路径和热点函数。             |
| **`trace`**      | BCC/bpftrace | 跟踪内核和用户空间的事件，可以自定义事件的输出。            |
| **`argdist`**    | BCC          | 获取函数参数的分布情况，帮助分析某些函数的调用模式。          |
| **`cpu`**        | bpftrace     | 通过 BPF 追踪每个 CPU 核心的使用情况，分析负载分布。     |
| **`profile`**    | BCC          | 采样并展示函数调用栈信息，帮助识别 CPU 使用热点。         |
| **`runqlat`**    | BCC          | 分析 CPU 运行队列的延迟，帮助诊断由于调度延迟导致的性能问题。   |
| **`biosnoop`**   | BCC          | 跟踪块 I/O 操作，识别磁盘 I/O 导致的 CPU 使用问题。   |
| **`biolatency`** | BCC          | 监控磁盘 I/O 的延迟，帮助诊断 CPU 在 I/O 阻塞中的瓶颈。 |
| **`mpstat`**     | bpftrace     | 显示每个 CPU 核心的利用率，分析多核系统的负载分布。        |
| **`tcpconnect`** | BCC          | 跟踪 TCP 连接的建立，帮助分析网络活动对 CPU 的影响。     |
### **BPF 工具的优势**
- **低开销**：相比传统的性能分析工具，BPF 工具通常能以低开销进行实时分析，尤其适用于生产环境。
- **灵活性**：BPF 提供了强大的灵活性，允许用户自定义事件追踪和数据收集方式。
- **高精度**：BPF 可以提供细粒度的性能数据，帮助用户从多方面（如函数调用、内存分配、I/O 操作等）深入分析 CPU 性能。
### **总结**
BPF 工具为 CPU 性能分析提供了强大且灵活的功能，从函数调用计数、堆栈分析到硬件性能监控，都能提供深入的洞察。使用这些工具，你可以准确地识别 CPU 性能瓶颈，并通过调整系统配置或优化代码来提高性能。
## BPF ONE-LINERS
## OPTIONAL EXERCISES
以下是基于 BPF 工具的可选练习，这些练习从简单任务（如使用 `execsnoop`）到更高级的任务（如使用 `bpftrace` 或 BCC 创建新工具）都有涉及。
### **1) 使用 `execsnoop(8)` 显示“man ls”命令的新进程**
- **目标**：学习如何使用 `execsnoop` 跟踪由 `man ls` 命令创建的新进程。
- **完成方法**：运行 `execsnoop`，然后执行 `man ls` 命令。你应该能看到由 `man` 命令创建的新进程。
```bash
sudo execsnoop | grep "man ls"
```
### **2) 使用 `execsnoop(8)` 带 `-t` 参数并输出到日志文件，运行 10 分钟，查看新进程**
- **目标**：使用带有时间戳的 `execsnoop` 并将输出记录到日志文件，持续 10 分钟。
- **完成方法**：运行 `execsnoop` 带 `-t` 参数将数据输出到日志文件中，记录 10 分钟。
```bash
sudo execsnoop -t > exec_log.txt &
sleep 600  # 运行 10 分钟
kill %1
```
查看日志文件 (`exec_log.txt`) 中显示的所有新进程。
### **3) 在测试系统上创建一个 CPU 超载**
- **目标**：通过创建两个 CPU 密集型的线程来模拟高 CPU 负载。
- **完成方法**：运行两个绑定到 CPU 0 的 CPU 密集型进程。
```bash
taskset -c 0 sh -c 'while :; do :; done' & 
taskset -c 0 sh -c 'while :; do :; done' &
```
运行负载后，使用以下工具分析 CPU 性能：
- `uptime` – 查看系统负载平均值。
- `mpstat -P ALL 1` – 监控所有核心的 CPU 利用率。
- `runqlen(8)` 和 `runqlat(8)` – 分析 CPU 0 的运行队列延迟。

完成后记得终止这些进程以释放 CPU 资源。

### **4) 开发一个工具或命令行工具，仅对 CPU 0 采样内核栈**

- **目标**：创建一个简单的工具或命令行工具，仅采样 CPU 0 的内核栈跟踪。
- **完成方法**：使用 `bpftrace` 针对 CPU 0 采样栈跟踪。

```bash
sudo bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[cpu] = count(); }'
```

### **5) 使用 `profile(8)` 捕获内核 CPU 栈，分析以下工作负载的 CPU 时间花费：**

```bash
dd if=/dev/nvme0n1p3 bs=8k iflag=direct | dd of=/dev/null bs=1
```

- **目标**：使用 `profile(8)` 分析 `dd` 工作负载的 CPU 时间。
- **完成方法**：在系统运行 `dd` 命令时使用 `profile` 采集数据，查看哪些函数消耗了最多的 CPU 时间。

```bash
sudo profile -f /tmp/dd_profile_output
```

修改输入文件为本地磁盘，然后重新进行性能分析。

### **6) 生成 (5) 输出的 CPU 火焰图**

- **目标**：通过生成火焰图来可视化 CPU 时间的消耗。
- **完成方法**：使用 `flamegraph.pl` 或类似的工具，从 `profile` 输出数据生成火焰图。

```bash
./flamegraph.pl /tmp/dd_profile_output > flamegraph.svg
```

### **7) 使用 `offcputime(8)` 捕获内核 CPU 栈，分析 (5) 工作负载的阻塞时间**

- **目标**：使用 `offcputime` 跟踪 CPU 在等待时（例如等待 I/O）花费的时间。
- **完成方法**：在 `dd` 命令运行时使用 `offcputime` 捕获并分析阻塞的时间。

```bash
sudo offcputime -p dd -o /tmp/dd_offcpu_output
```

### **8) 生成 (7) 输出的离 CPU 时间火焰图**

- **目标**：通过生成离 CPU 时间的火焰图来可视化阻塞时间的消耗。
- **完成方法**：使用火焰图工具生成离 CPU 时间的火焰图。

```bash
./flamegraph.pl /tmp/dd_offcpu_output > offcpu_flamegraph.svg
```

### **9) `execsnoop(8)` 仅能看到调用 `exec(2)`（`execve(2)`）的新进程，但某些进程可能通过 `fork(2)` 或 `clone(2)` 创建，而不是调用 `exec(2)`（例如创建工作进程）。编写一个名为 `procsnoop(8)` 的新工具，显示所有新进程及其详细信息。**

- **目标**：创建一个新工具，跟踪所有新进程（包括通过 `fork()` 或 `clone()` 创建的进程）。
- **完成方法**：使用 `fork()` 和 `clone()` 系统调用，或使用 `sched` tracepoints 来捕获进程创建事件。

```bash
sudo bpftrace -e 'tracepoint:sched:sched_process_fork { printf("New process: %d, parent: %d\n", pid, parent_pid); }'
```

### **10) 开发 `bpftrace` 版本的 `softirqs(8)`，打印软中断的名称。**

- **目标**：编写一个 `bpftrace` 脚本来跟踪软中断并打印其名称。
- **完成方法**：使用 `bpftrace` 跟踪软中断并打印它们的名称。

```bash
sudo bpftrace -e 'tracepoint:softirq:softirq_entry { printf("Softirq: %s\n", comm); }'
```

### **11) 实现 `cpudist(8)` 在 `bpftrace` 中的实现**

- **目标**：创建一个 `bpftrace` 工具，用来捕获并显示 CPU 时间分布。
- **完成方法**：使用 `bpftrace` 创建 CPU 时间分布的直方图。

```bash
sudo bpftrace -e 'tracepoint:sched:sched_switch { @[comm] = count(); }'
```

### **12) 使用 `cpudist(8)`（任意版本）分别显示自愿和非自愿上下文切换的直方图**

- **目标**：修改 `cpudist(8)`，分别显示自愿和非自愿上下文切换的直方图。
- **完成方法**：使用 `sched_switch` tracepoint 分别显示自愿和非自愿上下文切换。

```bash
sudo bpftrace -e 'tracepoint:sched:sched_switch /prev_state == "R"/ { @[comm] = count(); }'
```

### **13) （高级，未解决）开发一个工具，显示任务在 CPU 亲和力等待中花费的时间直方图：当其他 CPU 空闲时，任务处于可运行状态，但由于缓存温暖问题未被迁移。**

- **目标**：开发一个高级工具，跟踪任务在 CPU 亲和力等待中的时间。
- **完成方法**：这个练习需要深入了解内核调度和 CPU 亲和性，涉及 `kernel.sched_migration_cost_ns`、`task_hot()` 和 `can_migrate_task()` 等函数。