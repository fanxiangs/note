# Attaching to Internal Kernel Functions

[[null|]]The system call interface and the LSM interface are defined as stable interfaces in the Linux kernel; that is to say, they won’t change in a backward-incompatible way. If you write code today that uses the functions in those interfaces, they will continue to work in future versions of the kernel. These interfaces represent just a tiny fraction of the 30 million lines of code that make up the Linux kernel. Parts of that codebase are de facto stable, even if they are not officially declared as such; they haven’t changed for a long time and are unlikely to do so in the future.

It’s perfectly reasonable to write eBPF programs that attach to kernel functions that aren’t officially stable, with the expectation that they are likely to work for some considerable time to come. Also, given that it typically takes several years for a new kernel version to be widely deployed, it’s a safe bet that there will be plenty of time to address any incompatibility issues that might arise.

The Tetragon contributors include a number of kernel developers who have used their knowledge of kernel internals to identify some good, safe places where eBPF programs can be attached for useful security purposes. There are several [example TracingPolicy definitions](https://oreil.ly/51yRN) that make use of this knowledge. [[null|]]These examples monitor security events covering file operations, network activity, program executions, and changes to privileges—all the kinds of things a malicious actor would do as part of an attack.

Let’s come back to that example policy definition that attaches to `fd_install`. The “fd” stands for “file descriptor,” and the [comment in the source code for this function](https://oreil.ly/Tm6MN) tells us this function “Install\[s\] a file pointer in the fd array.” This happens when a file is opened, and it’s called after the file’s data structure has been populated in the kernel. It’s a safe place to check the name of the file—and in the earlier TracingPolicy example, it’s only of interest if the filename starts with “/etc/”.

Just as in LSM BPF programs, Tetragon eBPF programs have access to contextual information to allow them to make security decisions entirely within the kernel. Rather than reporting all events of a given type to user space, security-relevant events can be filtered within the kernel so that only the out-of-policy events get reported to user space.