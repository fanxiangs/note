# BPF Relocations

[[null|]][[null|]]The _libbpf_ library adapts eBPF programs to work with the data structure layout on the target kernel where they run, even if this layout is different from the kernel where the code was compiled. To do this, _libbpf_ needs the BPF CO-RE relocation information generated by Clang as part of the compilation process.

You can learn more about how the relocations work from the definition of `struct bpf_core_relo` in the [linux/bpf.h](https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711) header file:

    struct

The CO-RE relocation data for an eBPF program consists of one of these structures for each instruction that needs relocation. Suppose the instruction is setting a register to the value of a field within a structure. The `bpf_core_relo` structure for that instruction (identified by the `insn_off` field) encodes the BTF type of that structure (the `type_id` field) and also indicates how the field is accessed relative to that structure (`access_str_off`).

As you’ve just seen, the relocation data for the kernel data structures is generated automatically by Clang and encoded in the ELF object file. It’s the following line, which you’ll find near the start of the _vmlinux.h_ file, that causes Clang to do this:

    #pragma clang attribute push (__attribute__((preserve_access_index)), \

The `preserve_access_index` attribute tells Clang to generate BPF CO-RE relocations for a type definition. The `clang attribute push` part says that this attribute should be applied to all definitions until a `clang attribute pop`, which appears at the end of the file. That means Clang generates the relocation information for all the types defined in _vmlinux.h_.

[[null|]]You can see the relocations taking place when you load a BPF program, by using `bpftool` and turning on the debug information with the `-d` flag, like this:

bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello

This generates a lot of output, but the parts relating to relocation look like this:

libbpf: CO-RE relocating \[24\] struct user\_pt\_regs: found target candidate \[205\]
struct user\_pt\_regs in \[vmlinux\]
libbpf: prog 'hello': relo #0:  \[24\] struct user\_pt\_regs.regs\[0\]
(0:0:0 @ offset 0)
libbpf: prog 'hello': relo #0: matching candidate #0  \[205\] struct
user\_pt\_regs.regs\[0\] (0:0:0 @ offset 0)
libbpf: prog 'hello': relo #0: patched insn #1 (LDX/ST/STX) off 0 -> 0

In this example you can see that type ID 24 from the `hello` program’s BTF information refers to the structure called `user_pt_regs`. The _libbpf_ library has matched this against a kernel structure, also called `user_pt_regs`, that has type ID 205 in the _vmlinux_ BTF data set. In practice, because I compiled and loaded the program on the same machine, the type definitions are identical, so in this example the offset of 0 from the start of the structure remains unchanged, and the “patch” to instruction #1 leaves it unchanged.

In many applications you won’t want to ask users to run `bpftool` to load an eBPF program. Instead, you’ll want to build this functionality into a dedicated user space program that you supply as an executable. Let’s consider how to write this user space code.