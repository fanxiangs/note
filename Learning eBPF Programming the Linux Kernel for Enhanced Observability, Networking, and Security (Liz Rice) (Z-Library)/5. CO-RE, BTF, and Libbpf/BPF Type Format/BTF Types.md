# BTF Types

[[null|]]Knowing the ID of the BTF information, you can inspect its contents with the command `bpftool btf dump id` . When I ran this using the ID 149 that I obtained earlier, I got 69 lines of output, each of which is a type definition. I’ll just describe the first few lines, which should give you a good idea of how to interpret the rest. The BTF information from these first few lines relates to the `config` hash map, which was defined in the source code like this:

    struct

This hash table has keys of type `u32` and values of type `struct user_msg_t`. That structure holds a 12-byte `message` field. Let’s see how these types are defined in the corresponding BTF information.

The first three lines of the BTF output are as follows:

\[1\] TYPEDEF 'u32' type\_id=2
\[2\] TYPEDEF '\_\_u32' type\_id=3
\[3\] INT 'unsigned int' size=4 bits\_offset=0 nr\_bits=32 encoding=(none)

The number in square brackets at the start of each line is the type ID (so the first line, starting with `[1]`, defines `type_id 1`, etc.). Let’s dive into these three types in more detail:

*   Type 1 defines a type named `u32` and its type, defined by `type_id 2`, that is, the type defined in the line that starts with `[2]`. As you know, the keys in the hash table have this type `u32`.
    
*   Type 2 has the name `__u32` and the type defined by `type_id 3`.
    
*   Type 3 is an integer type with the name `unsigned int`, which is 4 bytes long.
    

All three of these types are synonyms for a 32-bit unsigned integer type. In C, the lengths of integers are platform dependent, so Linux defines types like `u32` to explicitly define integers of specific lengths. On this machine, `u32` corresponds to an unsigned integer. User space code that refers to these should use the synonym prefixed with underscores, as in `__u32`.

The next few types in the BTF output look like this:

\[4\] STRUCT 'user\_msg\_t' size=12 vlen=1
        'message' type\_id=6 bits\_offset=0
\[5\] INT 'char' size=1 bits\_offset=0 nr\_bits=8 encoding=(none)
\[6\] ARRAY '(anon)' type\_id=5 index\_type\_id=7 nr\_elems=12
\[7\] INT '\_\_ARRAY\_SIZE\_TYPE\_\_' size=4 bits\_offset=0 nr\_bits=32 encoding=(none)

These relate to the `user_msg_t` structure used for values in the `config` map:

*   Type 4 is the `user_msg_t` structure itself, and in total it is 12 bytes long. It contains one field named `message`, which is defined by type 6. The `vlen` field indicates how many fields there are in this definition.
    
*   Type 5 is named `char` and is a 1-byte integer—exactly the definition a C programmer would expect for a type called “char.”
    
*   Type 6 defines the type for that `message` field as an array with 12 elements. Each element has type 5 (it’s a `char`), and the array is indexed by type 7.
    
*   Type 7 is a 4-byte integer.
    

With these definitions, you can build a complete picture of how the `user_msg_t` structure is laid out in memory, as illustrated in [[#a_user_msg_t_structure_takes_onetwo_byt|Figure 5-1]].

![A user_msg_t structure takes 12 bytes of memory](/Learning%20eBPF%20Programming%20the%20Linux%20Kernel%20for%20Enhanced%20Observability,%20Networking,%20and%20Security%20(Liz%20Rice)%20(Z-Library)/images/lebp_0501.png)

##### Figure 5-1. A `user_msg_t` structure takes 12 bytes of memory

So far, all the entries have `bits_offset` set to `0`, but the next line of output has a structure with more than one field:

\[8\] STRUCT '\_\_\_\_btf\_map\_config' size=16 vlen=2
        'key' type\_id=1 bits\_offset=0
        'value' type\_id=4 bits\_offset=32

This is a structure definition for the key–value pairs stored in the map called `config`. I didn’t define this `____btf_map_config` type myself in the source code, but it has been generated by BCC. The key is of type `u32`, and the value is the `user_msg_t` structure. These correspond to the types 1 and 4 that you saw earlier.

The other important part of the BTF information about this structure is that the `value` field starts 32 bits after the start of the structure. That completely makes sense because the first 32 bits are needed to hold the `key` field.

##### Note

In C, structure fields get automatically aligned to boundaries, so you can’t simply assume that one field always follows directly after the previous one in memory. For example, consider a structure like this:

    struct

There would be 7 bytes of unused memory after the field called `letter` before the `number` field so that the 64-bit number can be aligned to a memory location divisible by 8.

It’s possible in some circumstances to turn on compiler packing to avoid this unused space, but it generally results in lower performance and—at least in my experience—it’s unusual to do so. More often, C programmers will design structures by hand to make efficient use of space.[[null|]]