理解操作系统及其内核对系统性能分析至关重要。在分析系统行为时，您将经常需要提出假设并进行测试，例如：系统调用如何执行，内核如何在 CPU 上调度线程，有限的内存如何影响性能，或文件系统如何处理 I/O。这些活动将要求您应用操作系统和内核的相关知识。

本章的学习目标是：

- **学习内核术语**：了解上下文切换、交换（swapping）、分页（paging）、抢占（preemption）等概念。  
- **理解内核的角色和系统调用的作用**。  
- **掌握内核内部的工作原理**：包括中断（interrupts）、调度器（schedulers）、虚拟内存（virtual memory）和 I/O 栈（I/O stack）等内容。  
- **了解内核性能特性的演变**：从 Unix 到 Linux 的性能功能变化。  
- **对扩展的 BPF（eBPF）有一个基本的理解**。 

本章概述了操作系统和内核，是本书其余内容的基础知识。如果您错过了操作系统课程，可以把它当作速成课程。留意自己知识的盲点，因为最后会有一个考试（开玩笑的；其实只是小测验）。有关内核内部的更多信息，请参见本章末尾的参考资料。

本章分为三个部分：

1. **术语**：列出了重要的核心术语。  
2. **背景知识**：总结了关键的操作系统和内核概念。  
3. **内核实现**：总结了 Linux 和其他内核的具体实现细节。  

与性能相关的领域，包括 CPU 调度、内存、磁盘、文件系统、网络以及许多特定的性能工具，将在后续章节中详细讨论。
## 3.1 Terminology

作为参考，以下是本书中使用的核心操作系统术语。许多术语也是本章及后续章节中将更详细解释的概念。

- **操作系统**：指安装在系统上的软件和文件，使得系统能够启动并执行程序。它包括内核、管理工具和系统库。
- **内核**：内核是管理系统的程序，包括（根据内核模型的不同）硬件设备、内存和 CPU 调度。它运行在特权 CPU 模式下，允许直接访问硬件，这种模式被称为内核模式。
- **进程**：操作系统的抽象和执行程序的环境。程序在用户模式下运行，并通过系统调用或陷入内核来访问内核模式（例如执行设备 I/O）。
- **线程**：一个可调度在 CPU 上运行的可执行上下文。内核有多个线程，一个进程包含一个或多个线程。
- **任务**：Linux 可运行的实体，既可以是进程（包含一个线程），也可以是多线程进程中的线程，或内核线程。
- **BPF 程序**：在 BPF 执行环境中运行的内核模式程序。

  > **注**：BPF 最初代表伯克利数据包过滤器，但现在该技术与伯克利、数据包或过滤几乎没有关系，因此 BPF 已成为一个独立的名称，而非首字母缩略词。

- **主内存**：系统的物理内存（例如 RAM）。
- **虚拟内存**：主内存的抽象，支持多任务处理和超额订阅。实际上，它是一种近乎无限的资源。
- **内核空间**：内核的虚拟内存地址空间。
- **用户空间**：进程的虚拟内存地址空间。
- **用户区**：用户级程序和库（例如 `/usr/bin`, `/usr/lib`...）。
- **上下文切换**：从一个线程或进程切换到另一个线程或进程。这是内核 CPU 调度程序的正常功能，涉及将正在运行的 CPU 寄存器集（线程上下文）切换为新的寄存器集。
- **模式切换**：在内核模式和用户模式之间切换。
- **系统调用（syscall）**：用户程序请求内核执行特权操作的明确协议，包括设备 I/O。
- **处理器**：不应与进程混淆，处理器是一个物理芯片，包含一个或多个 CPU。
- **陷阱**：发送到内核的信号，请求执行系统例程（特权操作）。陷阱类型包括系统调用、处理器异常和中断。
- **硬件中断**：物理设备发送给内核的信号，通常是请求 I/O 服务。中断是一种陷阱。
词汇表包括本章的更多术语供参考，包括地址空间，缓冲区，CPU，文件描述符，Posix和寄存器。

## 3.2 Background
以下部分描述了通用的操作系统和内核概念，帮助您理解任何操作系统。为了加深理解，本节还包含了一些与 Linux 相关的实现细节。
接下来的 3.3 节（**内核**）和 3.4 节（**Linux**）将重点介绍 Unix、BSD 和 Linux 内核的具体实现细节。

### 3.2.1 Kernel
内核是操作系统的核心软件，其功能取决于内核模型。类 Unix 操作系统（包括 Linux 和 BSD）使用的是**单体内核（monolithic kernel）**，它负责管理 CPU 调度、内存、文件系统、网络协议以及系统设备（如磁盘和网络接口）。单体内核模型如 **图 3.1** 所示。
![[Figure 3.1 Role of a monolithic operating system kernel.png]]

图中还展示了系统库，它通常用于提供比系统调用（syscalls）更丰富、更易用的编程接口。应用程序包括所有运行中的用户级软件，例如数据库、Web 服务器、管理工具和操作系统 Shell。

图中的系统库被表示为一条断开的环线，说明应用程序可以直接调用系统调用（syscalls）。例如，Golang 的运行时有其自身的系统调用层，无需依赖系统库（如 `libc`）。传统上，这类图通常用完整的环线表示，以反映从内核中心开始的特权递减模式（这一模型起源于 Unix 的前身 Multics [Graham 68]）。

> **注 2**：这种模型有一些例外情况。例如，内核旁路技术（Kernel Bypass Technology）有时用于网络，使用户层可以直接访问硬件（详见第 10 章《网络》，第 10.4.3 节《软件》，标题“内核旁路”）。在某些情况下，I/O 可以绕过系统调用接口直接提交给硬件（尽管初始化时仍需要系统调用），例如内存映射 I/O（Memory-Mapped I/O）、主缺页（详见第 7 章《内存》，第 7.2.3 节《需求分页》）、`sendfile(2)` 和 Linux 的 `io_uring`（详见第 5 章《应用程序》，第 5.2.6 节《非阻塞 I/O》）。

还有其他内核模型：
- **微内核（Microkernel）**：采用小型内核，将功能移到用户模式程序中。
- **单内核（Unikernel）**：将内核和应用程序代码编译为一个单独的程序。
- **混合内核（Hybrid Kernel）**：例如 Windows NT 内核，它结合了单体内核和微内核的特点。
  
这些模型将在第 3.5 节《其他主题》中总结。

最近，Linux 通过引入一种新的软件类型——**扩展 BPF（Extended BPF）**，改变了其内核模型。扩展 BPF 允许安全的内核模式应用程序运行，并提供了自己的内核 API：**BPF 助手函数（BPF Helpers）**。这使得某些应用程序和系统功能可以用 BPF 重写，从而实现更高的安全性和性能。这一模型如 **图 3.2** 所示。
![[Figure 3.2 BPF applications.png]]

扩展 BPF 的相关内容将在第 3.4.4 节《扩展 BPF》中总结。

**Kernel Execution**
内核是一个大型程序，通常有数百万行代码。它主要在用户级程序发出系统调用或设备发出中断时按需执行。一些内核线程以异步方式运行，用于内务管理，其中可能包括内核时钟例程和内存管理任务，但这些线程都尽量做到轻量级，只消耗极少的 CPU 资源。

频繁执行 I/O 的工作负载（如网络服务器）主要在内核上下文中执行。计算密集型工作负载通常在用户模式下运行，不受内核干扰。我们可能会认为内核不会影响这些计算密集型工作负载的性能，但在很多情况下，内核确实会影响工作负载的性能。最明显的就是 CPU 竞争，当其他线程竞争 CPU 资源时，内核调度程序需要决定哪个线程运行，哪个线程等待。内核还会选择线程在哪个 CPU 上运行，并可为进程选择硬件缓存更强或内存定位性更好的 CPU，从而显著提高性能。

### 3.2.2 Kernel and User Modes


## 3.3 Kernels
## 3.4 Linux
## 3.5 Other Topics
## 3.6 Kernel Comparisons
## 3.7 Exercises
## 3.8 References